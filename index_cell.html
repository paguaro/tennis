<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>Campi da tennis/padel pi√π vicini (mobile)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <link rel="stylesheet" href="https://js.arcgis.com/4.33/esri/themes/light/main.css" />
  <style>
    html, body, #viewDiv {
      height:100%;
      width:100%;
      margin:0;
      padding:0;
      -webkit-text-size-adjust:100%;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
    }
    .esri-ui .esri-widget,
    .esri-ui button,
    .esri-ui input,
    .esri-ui select {
      font-size:12px;
      line-height:1.2;
    }

    /* Barra icone (solo GPS) in alto a destra */
    .iconbar {
      position:absolute;
      top:15px;
      right:10px;
      z-index:6;
      display:flex;
      gap:6px;
      align-items:center;
    }
    .iconbtn {
      background:transparent;
      border:none;
      cursor:pointer;
      padding:6px;
      min-width:32px;
      font-size:20px;
      line-height:1;
      border-radius:8px;
      touch-action: manipulation;
    }
    .iconbtn:active { transform:scale(.96); }

    /* Pannello info "campi vicini" */
    #infoPanel {
      position:absolute;
      background:#fff;
      padding:6px 8px;
      border-radius:8px;
      box-shadow:0 2px 10px rgba(0,0,0,.15);
      font-size:9px;
      z-index:5;
      overflow-y:auto;
      transition: all 0.3s ease;
      top:100px;
      right:10px;
      width:min(240px,35vw);
      max-height:50%;
      opacity:0.9;
      -webkit-overflow-scrolling: touch;
    }
    #infoPanel.collapsed {
      max-height:24px;
      opacity:0.4;
      padding:4px;
    }
    #infoContent { font-size:12px; }

    .toggle-chip {
      position:absolute;
      top:4px;
      left:4px;
      background:#f2f2f2;
      border:1px solid #ddd;
      cursor:pointer;
      border-radius:6px;
      padding:2px 6px;
      font-size:14px;
      line-height:1.1;
      user-select:none;
      z-index:10;
      touch-action: manipulation;
    }

    .info-table {
      width:100%;
      border-collapse:collapse;
      font-size:11px;
    }
    .info-table th,
    .info-table td {
      text-align:left;
      padding:2px 4px;
      border-bottom:1px dotted #eee;
      vertical-align:top;
      word-break:break-word;
    }
    .info-table th {
      width:40%;
      color:#444;
      font-weight:600;
    }

    /* Toast & Error */
    #toast, #error {
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      color:#fff;
      padding:8px 12px;
      border-radius:6px;
      z-index:10;
      display:none;
      font-size:13px;
      box-shadow:0 3px 10px rgba(0,0,0,.2);
    }
    #toast { top:10px; background:#323232; }
    #error { top:50px; background:#d32f2f; }

    /* Loader iniziale */
    #loadingMessage {
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      pointer-events:none;
      z-index:7;
    }
    #loadingBox {
      background:#fff;
      padding:12px 14px;
      border-radius:10px;
      box-shadow:0 4px 16px rgba(0,0,0,.2);
      font-size:14px;
    }
    .hidden { display:none !important; }

    /* Legenda personalizzata */
    .custom-legend {
      background:white;
      padding:8px;
      border-radius:6px;
      box-shadow:0 2px 8px rgba(0,0,0,0.15);
      max-height:250px;
      overflow-y:auto;
      font-size:11px;
    }
    .custom-legend h4 {
      margin:0 0 8px 0;
      font-size:12px;
    }
    .legend-item {
      display:flex;
      align-items:center;
      margin-bottom:6px;
      padding:2px;
    }
    .legend-color {
      width:14px;
      height:14px;
      margin-right:6px;
      border-radius:50%;
    }
    .line-color {
      width:14px;
      height:3px;
      margin-right:6px;
      background-color:rgba(255,0,0,0.6);
    }
    .legend-label { flex:1; font-size:11px; }
    .legend-checkbox {
      margin-left:6px;
      transform:scale(0.8);
    }

    /* Scala dinamica */
    #scaleBar {
      position:absolute;
      bottom:20px;
      left:50%;
      transform:translateX(-50%);
      background:rgba(255, 255, 255, 0.8);
      padding:2px 5px;
      border-radius:2px;
      font-size:8px;
      z-index:5;
      box-shadow:0 1px 3px rgba(0,0,0,0.3);
      color:#ff0000;
      font-weight:bold;
    }

    /* Widget Selezione (semplice) */
    .select-widget {
      background:#fff;
      padding:10px;
      border-radius:8px;
      box-shadow:0 2px 8px rgba(0,0,0,.15);
      max-width:min(300px, 70vw);
      font-size:11px;
    }
    .select-widget h4 {
      margin:0 0 8px 0;
      font-size:13px;
    }
    .sel-row {
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      margin-top:6px;
    }
    .sel-row button {
      flex:1;
      min-width:120px;
    }
    .sel-counter {
      font-size:11px;
      margin:6px 0;
      color:#333;
    }

    button {
      background-color:#0079c1;
      color:#fff;
      border:none;
      cursor:pointer;
      border-radius:6px;
      padding:6px 8px;
      font-size:12px;
      touch-action: manipulation;
    }
    button:hover { background-color:#005a8c; }
    .btn-ghost {
      background:#fff;
      color:#000;
      border:1px solid #ccc;
    }

    /* Lista risultati "campi pi√π vicini" cliccabile */
    .nearest-list {
      margin:0;
      padding:0;
    }
    .nearest-item {
      display:flex;
      align-items:flex-start;
      gap:6px;
      padding:3px 4px;
      border-radius:4px;
      cursor:pointer;
      transition:background-color 0.15s ease;
      touch-action: manipulation;
    }
    .nearest-item:hover {
      background:#f0f7ff;
    }
    .nearest-dot {
      flex:0 0 8px;
      width:8px;
      height:8px;
      border-radius:50%;
      margin-top:5px;
    }
    .nearest-text {
      flex:1;
      font-size:12px;
    }
    .nearest-name {
      margin:0;
    }
    .nearest-distance {
      font-size:11px;
      color:#555;
    }
  </style>
</head>
<body>
  <div id="viewDiv"></div>

  <!-- Barra icone: solo GPS -->
  <div class="iconbar">
    <button id="btnGPS" class="iconbtn" title="Localizzami">üìç</button>
  </div>

  <!-- Pannello info "campi vicini" -->
  <div id="infoPanel">
    <button id="toggleInfo" class="toggle-chip" title="Minimizza / Espandi">üìã</button>
    <div id="infoContent"></div>
  </div>

  <!-- Scala dinamica -->
  <div id="scaleBar"></div>

  <!-- Toast + Error + Loader -->
  <div id="toast"></div>
  <div id="error"></div>
  <div id="loadingMessage"><div id="loadingBox">Caricamento campi da tennis‚Ä¶</div></div>

  <script src="https://js.arcgis.com/4.33/"></script>
  <script>
  require([
    "esri/Map","esri/views/MapView",
    "esri/layers/GraphicsLayer","esri/Graphic",
    "esri/geometry/Point","esri/geometry/Polyline","esri/geometry/Extent",
    "esri/symbols/SimpleMarkerSymbol","esri/symbols/SimpleLineSymbol",
    "esri/widgets/Search","esri/widgets/BasemapGallery","esri/widgets/Expand",
    "esri/widgets/Zoom","esri/widgets/Home",
    "esri/request","esri/core/reactiveUtils",
    "esri/widgets/Sketch/SketchViewModel","esri/geometry/geometryEngine","esri/geometry/support/webMercatorUtils"
  ], function(
    Map, MapView,
    GraphicsLayer, Graphic,
    Point, Polyline, Extent,
    SimpleMarkerSymbol, SimpleLineSymbol,
    Search, BasemapGallery, Expand,
    Zoom, Home,
    esriRequest, reactiveUtils,
    SketchViewModel, geometryEngine, webMercatorUtils
  ){

    /* ====== MAPPA & UI BASE ====== */
    const map = new Map({ basemap: "streets-navigation-vector" });
    const view = new MapView({
      container: "viewDiv",
      map,
      center: [12, 42],
      zoom: 5,
      popupEnabled: true,
      ui: { components: ["attribution"] },
      optimizePanAnimation: true
    });

    /* ====== LAYERS ====== */
    const tennisLayer        = new GraphicsLayer({ title:"Campi da tennis/padel", listMode:"show" });
    const linesLayer         = new GraphicsLayer({ title:"Linee di connessione", listMode:"show" });
    const locLayer           = new GraphicsLayer({ title:"Mia posizione", listMode:"show" });
    const selectionDrawLayer = new GraphicsLayer({ title:"Disegno selezione", listMode:"hide" });
    const selectionLayer     = new GraphicsLayer({ title:"Selezione", listMode:"show" });

    map.addMany([tennisLayer, linesLayer, locLayer, selectionDrawLayer, selectionLayer]);

    /* ====== WIDGETS ====== */
    const zoomWidget = new Zoom({ view });
    const homeWidget = new Home({ view });
    view.ui.add(zoomWidget, { position:"top-left", index:0 });
    view.ui.add(homeWidget, { position:"top-left", index:1 });

    const legendContainer = document.createElement("div");
    legendContainer.className = "custom-legend";
    legendContainer.innerHTML = '<h4>Legenda</h4>';
    const legendExpand = new Expand({
      view,
      content: legendContainer,
      expanded:false,
      expandIconClass:"esri-icon-layer-list",
      expandTooltip:"Legenda"
    });
    view.ui.add(legendExpand, { position:"top-left", index:2 });

    const searchWidget = new Search({ view });
    const searchExpand = new Expand({
      view,
      content: searchWidget,
      expanded:false,
      expandIcon:"search",
      expandTooltip:"Cerca luogo"
    });
    view.ui.add(searchExpand, { position:"top-left", index:3 });

    const basemapGallery = new BasemapGallery({ view });
    const bgExpand = new Expand({
      view,
      content: basemapGallery,
      expandIconClass:"esri-icon-basemap",
      expandTooltip:"Cambia mappa di base"
    });
    view.ui.add(bgExpand, "bottom-right");
    basemapGallery.watch("activeBasemap", () => { bgExpand.expanded = false; });

    /* ====== DOM UI ELEMENTI ====== */
    const btnGPS      = document.getElementById("btnGPS");
    const infoPanel   = document.getElementById("infoPanel");
    const infoContent = document.getElementById("infoContent");
    const toggleInfo  = document.getElementById("toggleInfo");
    const toast       = document.getElementById("toast");
    const errorBox    = document.getElementById("error");
    const loadingMsg  = document.getElementById("loadingMessage");
    const scaleBar    = document.getElementById("scaleBar");

    toggleInfo.addEventListener("click", () => {
      const collapsed = infoPanel.classList.contains("collapsed");
      if (collapsed) {
        infoPanel.classList.remove("collapsed");
        toggleInfo.textContent = "üìã";
      } else {
        infoPanel.classList.add("collapsed");
        toggleInfo.textContent = "‚ñ∂";
      }
    });

    /* ====== STATO ====== */
    const allPoints = [];
    let spatialGrid = {};
    let nearest = [];

    let showTennis = true;
    let showPadel  = true;

    /* ====== SIMBOLI ====== */
    const symLocation = new SimpleMarkerSymbol({
      color:[0,200,0,0.9],
      outline:{ color:[255,255,255], width:2 },
      size:10
    });
    const symLine = new SimpleLineSymbol({
      color:[255,0,0,0.7],
      width:1.5,
      style:"short-dash"
    });
    const symSelectedPoint = new SimpleMarkerSymbol({
      style:"circle",
      color:[0,0,0,0],
      outline:{ color:[255,215,0,0.95], width:2 },
      size:8
    });
    const symSelectedLine = new SimpleLineSymbol({
      color:[255,215,0,0.95],
      width:3
    });

    function createCourtSymbol(attrs) {
      const sportValue = (attrs && attrs.sport ? String(attrs.sport) : "").toLowerCase();
      const isPadel = sportValue === "padel";
      return new SimpleMarkerSymbol({
        color: isPadel ? [255, 0, 0, 0.9] : [0, 112, 255, 0.9],
        outline: {
          color: isPadel ? [255, 200, 200, 1] : [80, 220, 255, 1],
          width: 1
        },
        size: 4
      });
    }

    function isCourtVisibleByFilter(graphic) {
      const attrs = graphic.attributes || {};
      const sportValue = (attrs.sport ? String(attrs.sport) : "").toLowerCase();
      if (sportValue === "padel")  return showPadel;
      if (sportValue === "tennis") return showTennis;
      return true;
    }

    function updateCourtVisibility() {
      tennisLayer.graphics.items.forEach(g => {
        g.visible = isCourtVisibleByFilter(g);
      });
    }

    /* ====== UTIL UI ====== */
    function showToast(msg, ms=2000) {
      toast.textContent = msg;
      toast.style.display = "block";
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toast.style.display = "none", ms);
    }
    function showError(msg, ms=5000) {
      errorBox.textContent = msg;
      errorBox.style.display = "block";
      clearTimeout(showError._t);
      showError._t = setTimeout(() => errorBox.style.display = "none", ms);
    }

    function updateLegend() {
      while (legendContainer.children.length > 1) {
        legendContainer.removeChild(legendContainer.lastChild);
      }
      map.layers.forEach(layer => {
        if (!layer.title || layer.listMode !== "show") return;

        if (layer === tennisLayer) {
          const itemT = document.createElement("div");
          itemT.className = "legend-item";

          const colorT = document.createElement("div");
          colorT.className = "legend-color";
          colorT.style.backgroundColor = "rgba(0,112,255,0.85)";

          const labelT = document.createElement("span");
          labelT.className = "legend-label";
          labelT.textContent = "Campi da tennis";

          const checkboxT = document.createElement("input");
          checkboxT.type = "checkbox";
          checkboxT.className = "legend-checkbox";
          checkboxT.checked = showTennis;
          checkboxT.addEventListener("change", () => {
            showTennis = checkboxT.checked;
            updateCourtVisibility();
          });

          itemT.appendChild(colorT);
          itemT.appendChild(labelT);
          itemT.appendChild(checkboxT);
          legendContainer.appendChild(itemT);

          const itemP = document.createElement("div");
          itemP.className = "legend-item";

          const colorP = document.createElement("div");
          colorP.className = "legend-color";
          colorP.style.backgroundColor = "rgba(255,0,0,0.9)";

          const labelP = document.createElement("span");
          labelP.className = "legend-label";
          labelP.textContent = "Campi da padel";

          const checkboxP = document.createElement("input");
          checkboxP.type = "checkbox";
          checkboxP.className = "legend-checkbox";
          checkboxP.checked = showPadel;
          checkboxP.addEventListener("change", () => {
            showPadel = checkboxP.checked;
            updateCourtVisibility();
          });

          itemP.appendChild(colorP);
          itemP.appendChild(labelP);
          itemP.appendChild(checkboxP);
          legendContainer.appendChild(itemP);

        } else {
          const item = document.createElement("div");
          item.className = "legend-item";

          const colorBox = document.createElement("div");
          if (layer.title === "Linee di connessione") {
            colorBox.className = "line-color";
          } else if (layer.title === "Mia posizione") {
            colorBox.className = "legend-color";
            colorBox.style.backgroundColor = "rgba(0,200,0,0.9)";
          } else if (layer.title === "Selezione") {
            colorBox.className = "legend-color";
            colorBox.style.backgroundColor = "rgba(255,215,0,0.95)";
          } else {
            colorBox.className = "legend-color";
            colorBox.style.backgroundColor = "rgba(150,150,150,0.8)";
          }

          const label = document.createElement("span");
          label.className = "legend-label";
          label.textContent = layer.title;

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "legend-checkbox";
          checkbox.checked = layer.visible;
          checkbox.addEventListener("change", () => {
            layer.visible = checkbox.checked;
          });

          item.appendChild(colorBox);
          item.appendChild(label);
          item.appendChild(checkbox);
          legendContainer.appendChild(item);
        }
      });
    }
    map.layers.on("change", updateLegend);

    // Scala dinamica
    function updateScaleBar() {
      try {
        if (!view || !view.ready || !view.container) return;

        const width = view.width;
        const height = view.height;
        if (!width || !height) return;

        const cx = width / 2;
        const cy = height / 2;
        const p1Screen = { x: cx - 50, y: cy };
        const p2Screen = { x: cx + 50, y: cy };

        const p1Map = view.toMap(p1Screen);
        const p2Map = view.toMap(p2Screen);
        if (!p1Map || !p2Map) return;

        let p1 = p1Map;
        let p2 = p2Map;

        if (p1.spatialReference && p1.spatialReference.wkid !== 4326) {
          p1 = webMercatorUtils.webMercatorToGeographic(p1);
          p2 = webMercatorUtils.webMercatorToGeographic(p2);
        }

        const dMeters = haversineMeters(
          { latitude: p1.latitude, longitude: p1.longitude },
          { latitude: p2.latitude, longitude: p2.longitude }
        );

        if (!isFinite(dMeters) || dMeters <= 0) return;

        const pow10 = Math.pow(10, Math.floor(Math.log10(dMeters)));
        const norm = dMeters / pow10;
        let mult;
        if (norm < 1.5) mult = 1;
        else if (norm < 3.5) mult = 2;
        else if (norm < 7.5) mult = 5;
        else mult = 10;
        const nice = mult * pow10;

        let label, unit;
        if (nice >= 1000) {
          label = (nice / 1000).toLocaleString('it-IT');
          unit = "km";
        } else {
          label = nice.toLocaleString('it-IT');
          unit = "m";
        }

        scaleBar.textContent = `${label} ${unit}`;
      } catch (e) {
        console.error("Errore updateScaleBar:", e);
      }
    }
    view.watch("scale", updateScaleBar);
    view.watch("center", updateScaleBar);

    /* ====== CARICAMENTO GEOJSON CAMPI ====== */
    const tennisGeoJsonUrl = "tennis_it.geojson";

    esriRequest(tennisGeoJsonUrl, { responseType:"json" })
      .then((r) => {
        const gj = r.data;
        if (!gj || !gj.features) throw new Error("GeoJSON vuoto o non valido.");
        ingestCourts(gj.features);
        updateLegend();
        updateScaleBar();
        updateCourtVisibility();
      })
      .catch((e) => {
        console.error(e);
        showError("Errore nel caricamento dei campi.");
      })
      .finally(() => {
        loadingMsg.classList.add("hidden");
      });

    function createCourtPopupTemplate(attrs) {
      const sportValue = (attrs && attrs.sport ? String(attrs.sport) : "").toLowerCase();
      const isPadel = sportValue === "padel";
      const titolo = attrs.name || (isPadel ? "Campo da padel" : "Campo da tennis");

      return {
        title: titolo,
        content: function(event) {
          const graphic = event.graphic;
          const a = graphic.attributes || {};
          const g = graphic.geometry;
          const lat = Number(typeof g.latitude === 'number' ? g.latitude : g.y).toFixed(6);
          const lon = Number(typeof g.longitude === 'number' ? g.longitude : g.x).toFixed(6);
          return buildTable(a) +
            "<div style='margin-top:8px;'><strong>Coordinate:</strong> " +
            lat + ", " + lon + "</div>";
        },
        actions: [
          {
            title:"Waze",
            id:"open-waze",
            image:"https://paguaro.github.io/Points_icnf/waze-icon.png"
          },
          {
            title:"Google Maps",
            id:"open-google-maps",
            image:"https://paguaro.github.io/Points_icnf/google-maps-icon.png"
          },
          {
            title:"Copia coordinate",
            id:"copy-coords",
            image:"https://paguaro.github.io/Points_icnf/coordinates-icon.png"
          },
          {
            title:"Copia GeoJSON",
            id:"copy-geojson",
            image:"https://paguaro.github.io/Points_icnf/geojson-icon.png"
          }
        ]
      };
    }

    function ingestCourts(features) {
      for (const f of features) {
        const c = f.geometry && f.geometry.coordinates;
        if (!c || c.length < 2) continue;
        const pt = new Point({
          longitude: +c[0],
          latitude: +c[1]
        });
        const attrs = f.properties || {};
        const symbol = createCourtSymbol(attrs);

        const g = new Graphic({
          geometry: pt,
          attributes: attrs,
          symbol: symbol,
          popupTemplate: createCourtPopupTemplate(attrs)
        });
        allPoints.push(g);
        tennisLayer.add(g);
      }

      if (tennisLayer.graphics.items.length) {
        fitToGraphics(tennisLayer.graphics.items, 60);
      }
      if (allPoints.length) {
        buildSpatialGrid(allPoints);
        if (view.center) findNearest(view.center);
      }
    }

    function buildTable(attrs) {
      const rows = Object.entries(attrs || {})
        .filter(([k, v]) => v != null && v !== "")
        .sort(([k1], [k2]) => k1.localeCompare(k2));
      let html = "<table class='info-table'><tbody>";
      for (const [k, v] of rows) {
        const label = k.replace(/_/g," ").replace(/\b\w/g,l=>l.toUpperCase());
        html += "<tr><th>" + label + "</th><td>" + v + "</td></tr>";
      }
      html += "</tbody></table>";
      return html;
    }

    reactiveUtils.on(() => view.popup, "trigger-action", (event) => {
      const graphic = view.popup.selectedFeature;
      if (!graphic) return;
      const geom = graphic.geometry;
      const latVal = (typeof geom.latitude === 'number' ? geom.latitude : geom.y);
      const lonVal = (typeof geom.longitude === 'number' ? geom.longitude : geom.x);
      const lat = (latVal != null ? latVal.toFixed(6) : '');
      const lon = (lonVal != null ? lonVal.toFixed(6) : '');
      const attrs = graphic.attributes;

      switch (event.action.id) {
        case "open-waze":
          openNavigation("waze", lat, lon);
          break;
        case "open-google-maps":
          openNavigation("google", lat, lon);
          break;
        case "copy-coords":
          copyToClipboard(lat + ", " + lon);
          showToast("Coordinate copiate!");
          break;
        case "copy-geojson":
          copyGeoJSON(attrs, lat, lon);
          break;
      }
    });

    function openNavigation(app, lat, lon) {
      const url = app === "waze"
        ? "https://waze.com/ul?ll=" + lat + "," + lon + "&navigate=yes"
        : "https://www.google.com/maps/dir/?api=1&destination=" + lat + "," + lon;
      window.open(url, "_blank");
    }

    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).catch(function(err) {
        console.error("Errore nella copia:", err);
        var ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
      });
    }

    function copyGeoJSON(attributes, lat, lon) {
      const feature = {
        type:"Feature",
        geometry:{
          type:"Point",
          coordinates:[ parseFloat(lon), parseFloat(lat) ]
        },
        properties:{ ...attributes }
      };
      copyToClipboard(JSON.stringify(feature, null, 2));
      showToast("GeoJSON copiato negli appunti!");
    }

    function fitToGraphics(graphics, padding=40) {
      if (!graphics || !graphics.length) return;
      let xmin=Infinity, ymin=Infinity, xmax=-Infinity, ymax=-Infinity;
      for (const g of graphics) {
        const geom = g.geometry;
        if (!geom) continue;
        const x = (geom.longitude != null ? geom.longitude : geom.x);
        const y = (geom.latitude != null ? geom.latitude : geom.y);
        if (typeof x !== "number" || typeof y !== "number") continue;
        if (x < xmin) xmin = x;
        if (y < ymin) ymin = y;
        if (x > xmax) xmax = x;
        if (y > ymax) ymax = y;
      }
      if (!isFinite(xmin) || !isFinite(ymin) || !isFinite(xmax) || !isFinite(ymax)) return;
      const ext = new Extent({
        xmin, ymin, xmax, ymax,
        spatialReference:{ wkid:4326 }
      });
      view.goTo({ target: ext, padding }).catch(()=>{});
    }

    function buildSpatialGrid(points, gridSize=0.5) {
      spatialGrid = {};
      for (const p of points) {
        const lon = p.geometry.longitude;
        const lat = p.geometry.latitude;
        const gx = Math.floor(lon / gridSize);
        const gy = Math.floor(lat / gridSize);
        const key = gx + "," + gy;
        if (!spatialGrid[key]) spatialGrid[key] = [];
        spatialGrid[key].push(p);
      }
    }

    function haversineMeters(a,b) {
      const R = 6371000;
      const toRad = function(d){ return d*Math.PI/180; };
      const dLat = toRad(b.latitude - a.latitude);
      const dLon = toRad(b.longitude - a.longitude);
      const lat1 = toRad(a.latitude);
      const lat2 = toRad(b.latitude);
      const s = Math.sin(dLat/2)*Math.sin(dLat/2) +
                Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)*Math.sin(dLon/2);
      return Math.round(2*R*Math.asin(Math.sqrt(s)));
    }

    function findNearest(pt) {
      if (!allPoints.length || !pt) return;
      linesLayer.removeAll();

      if (!Object.keys(spatialGrid).length) {
        buildSpatialGrid(allPoints);
      }

      const active = allPoints.filter(isCourtVisibleByFilter);
      if (!active.length) {
        nearest = [];
        renderInfo();
        return;
      }

      const gridSize = 0.5;
      const gx = Math.floor(pt.longitude / gridSize);
      const gy = Math.floor(pt.latitude / gridSize);
      let candidates = [];

      for (let x = gx-2; x <= gx+2; x++) {
        for (let y = gy-2; y <= gy+2; y++) {
          const key = x + "," + y;
          const cell = spatialGrid[key];
          if (!cell) continue;
          for (const g of cell) {
            if (active.indexOf(g) !== -1) {
              candidates.push({
                feature: g,
                distance: haversineMeters(pt, g.geometry)
              });
            }
          }
        }
      }

      if (candidates.length < 5) {
        candidates = active.map(function(g){
          return {
            feature: g,
            distance: haversineMeters(pt, g.geometry)
          };
        });
      }

      nearest = candidates
        .filter(function(o){ return o.distance <= 5000; })
        .sort(function(a,b){ return a.distance - b.distance; })
        .slice(0, 5);

      for (const item of nearest) {
        const line = new Polyline({
          paths: [
            [pt.longitude, pt.latitude],
            [item.feature.geometry.longitude, item.feature.geometry.latitude]
          ],
          spatialReference:{ wkid:4326 }
        });
        linesLayer.add(new Graphic({ geometry: line, symbol: symLine }));
      }

      renderInfo();
    }

    // auto: quando la view √® pronta e quando si ferma
    view.when(function() {
      updateScaleBar();
      if (view.center) findNearest(view.center);
    });

    reactiveUtils.watch(
      function(){ return view.stationary; },
      function(stationary) {
        if (stationary && view.center) {
          findNearest(view.center.clone());
        }
      }
    );

    // misura anche da click/tap
    view.on("click", function(event) {
      if (!event.mapPoint) return;
      let pt = event.mapPoint;
      if (pt.spatialReference && pt.spatialReference.wkid !== 4326) {
        pt = webMercatorUtils.webMercatorToGeographic(pt);
      }
      findNearest(pt);
    });

    // pan/zoom + popup su uno dei 5 record
    function focusNearestIndex(idx) {
      const item = nearest[idx];
      if (!item || !item.feature || !item.feature.geometry) return;
      const g = item.feature;
      const geom = g.geometry;
      view.goTo({ target: geom, zoom: 17 }).catch(()=>{});
      view.openPopup({
        features:[g],
        location: geom
      });
    }

    function attachNearestEvents() {
      const rows = infoContent.querySelectorAll(".nearest-item");
      for (var i=0; i<rows.length; i++) {
        rows[i].addEventListener("click", function() {
          const idx = Number(this.getAttribute("data-idx"));
          if (!isNaN(idx)) {
            focusNearestIndex(idx);
          }
        });
      }
    }

    function renderInfo() {
      let html = "<h4 style='margin:4px 0 6px; text-align:center;'>Campi pi√π vicini <small>(entro 5 km)</small>:</h4>";

      if (!nearest.length) {
        html += "<p style='margin:0'>Nessun campo trovato nella distanza impostata.</p>";
      } else {
        html += "<div class='nearest-list'>";
        nearest.forEach(function(o, idx) {
          const a = o.feature.attributes || {};
          const name = a.name || ("Campo #" + (a.OBJECTID != null ? a.OBJECTID : "sconosciuto"));
          const sportValue = (a.sport ? String(a.sport) : "").toLowerCase();
          const sportLabel = sportValue ? (" (" + sportValue + ")") : "";
          const distLabel = o.distance.toLocaleString('it-IT') + " m";

          let dotColor = "#999999";
          if (sportValue === "padel") {
            dotColor = "#ff0000";
          } else if (sportValue === "tennis") {
            dotColor = "#0070ff";
          }

          html +=
            '<div class="nearest-item" data-idx="' + idx + '">' +
              '<span class="nearest-dot" style="background-color:' + dotColor + ';"></span>' +
              '<div class="nearest-text">' +
                '<div class="nearest-name"><strong>' + name + '</strong>' + sportLabel + '</div>' +
                '<div class="nearest-distance">' + distLabel + '</div>' +
              '</div>' +
            '</div>';
        });
        html += "</div>";
      }

      infoContent.innerHTML = html;
      attachNearestEvents();
    }

    /* ====== GPS ====== */
    btnGPS.addEventListener("click", function() {
      if (!navigator.geolocation) {
        showError("Geolocalizzazione non supportata.");
        return;
      }
      navigator.geolocation.getCurrentPosition(
        function(p) {
          const pt = new Point({
            longitude: p.coords.longitude,
            latitude: p.coords.latitude
          });
          view.goTo({ target: pt, zoom: 14 }).catch(()=>{});
          locLayer.removeAll();
          locLayer.add(new Graphic({ geometry: pt, symbol: symLocation }));
          showToast("Posizione impostata");
          findNearest(pt);
        },
        function() {
          showError("Impossibile ottenere la posizione.");
        },
        { enableHighAccuracy:true, maximumAge:30000, timeout:10000 }
      );
    });

    /* ====== WIDGET SELEZIONE ====== */
    const selContainer = document.createElement("div");
    selContainer.className = "select-widget";
    selContainer.innerHTML = `
      <h4>Selezione</h4>
      <div class="sel-row">
        <button id="btnSelectRect">Rettangolo</button>
        <button id="btnClearSel" class="btn-ghost">Pulisci</button>
      </div>
      <div class="sel-row" style="margin-top:4px;">
        <button id="btnCopySel" class="btn-ghost">Copia GeoJSON</button>
        <button id="btnDownloadSel">Scarica .geojson</button>
      </div>
      <div class="sel-counter">Selezionati: <strong id="selCount">0</strong></div>
    `;

    const selectExpand = new Expand({
      view,
      content: selContainer,
      expanded:false,
      expandIconClass:"esri-icon-cursor",
      expandTooltip:"Selezione"
    });
    view.ui.add(selectExpand, { position:"top-left", index:4 });

    const sketchVM = new SketchViewModel({
      view,
      layer: selectionDrawLayer,
      polygonSymbol: {
        type:"simple-fill",
        color:[0,0,0,0.06],
        outline:{ color:[0,0,0,0.5], width:1 }
      }
    });

    const selCountEl    = selContainer.querySelector("#selCount");
    const btnSelectRect = selContainer.querySelector("#btnSelectRect");
    const btnClearSel   = selContainer.querySelector("#btnClearSel");
    const btnCopySel    = selContainer.querySelector("#btnCopySel");
    const btnDownloadSel= selContainer.querySelector("#btnDownloadSel");

    let selectedItems = [];

    const toWGS84 = function(geom) {
      if (!geom) return geom;
      const sr = geom.spatialReference;
      if (sr && (sr.wkid === 4326 || sr.isWGS84)) return geom;
      return webMercatorUtils.webMercatorToGeographic(geom);
    };

    btnSelectRect.addEventListener("click", function() {
      selectionDrawLayer.removeAll();
      selectionLayer.removeAll();
      selectedItems = [];
      updateSelCounter();
      sketchVM.create("rectangle");
    });
    btnClearSel.addEventListener("click", function() {
      selectionDrawLayer.removeAll();
      selectionLayer.removeAll();
      selectedItems = [];
      updateSelCounter();
    });

    sketchVM.on("create", function(evt) {
      if (evt.state === "complete" && evt.graphic && evt.graphic.geometry) {
        const rectWgs = toWGS84(evt.graphic.geometry);
        runSelection(rectWgs);
      }
    });

    function updateSelCounter() {
      selCountEl.textContent = String(selectedItems.length);
    }

    function visibleGraphicsLayers() {
      const ignore = new Set([linesLayer, locLayer, selectionDrawLayer, selectionLayer]);
      const arr = [];
      map.layers.forEach(function(layer) {
        if (layer.visible && layer instanceof GraphicsLayer && !ignore.has(layer)) {
          arr.push(layer);
        }
      });
      return arr;
    }

    function quickPointInExtent(pt, ext) {
      return (
        pt.longitude >= ext.xmin &&
        pt.longitude <= ext.xmax &&
        pt.latitude  >= ext.ymin &&
        pt.latitude  <= ext.ymax
      );
    }

    function runSelection(rectWgs) {
      selectionLayer.removeAll();
      selectedItems = [];
      const layers = visibleGraphicsLayers();
      const ext = rectWgs.extent;

      layers.forEach(function(layer) {
        layer.graphics.items.forEach(function(g) {
          if (!g.geometry) return;
          if (layer === tennisLayer && !g.visible) return;

          const gWgs = (g.geometry.spatialReference && g.geometry.spatialReference.wkid === 4326)
            ? g.geometry
            : toWGS84(g.geometry);
          const type = gWgs.type;

          if (type === "point") {
            if (!quickPointInExtent(gWgs, ext)) return;
          } else {
            const gExt = gWgs.extent;
            if (gExt && !geometryEngine.intersects(ext, gExt)) return;
          }

          const hit = geometryEngine.contains(rectWgs, gWgs);
          if (hit) {
            selectedItems.push({
              geometry: gWgs.clone(),
              attributes:{ ...g.attributes },
              layerTitle: layer.title || "layer"
            });
            if (type === "point") {
              selectionLayer.add(new Graphic({ geometry:gWgs, symbol:symSelectedPoint }));
            } else {
              selectionLayer.add(new Graphic({ geometry:gWgs, symbol:symSelectedLine }));
            }
          }
        });
      });

      updateSelCounter();
      showToast("Selezionate " + selectedItems.length + " feature");
      if (selectedItems.length) {
        const geoms = selectedItems.map(function(it){ return it.geometry; });
        const unionExt = geoms.reduce(function(acc, g) {
          return acc ? acc.union(g.extent) : g.extent;
        }, null);
        if (unionExt) {
          view.goTo({ target: unionExt.expand(1.2) }).catch(()=>{});
        }
      }
    }

    function selectionToGeoJSON() {
      const fc = { type:"FeatureCollection", features:[] };
      selectedItems.forEach(function(it) {
        const g = it.geometry;
        let geom = null;
        if (g.type === "point") {
          geom = {
            type:"Point",
            coordinates:[
              (g.longitude != null ? g.longitude : g.x),
              (g.latitude != null ? g.latitude : g.y)
            ]
          };
        } else if (g.type === "polyline") {
          if (g.paths && g.paths.length > 1) {
            geom = {
              type:"MultiLineString",
              coordinates: g.paths.map(function(path){ return path.map(function(pair){ return [pair[0], pair[1]]; }); })
            };
          } else {
            const firstPath = (g.paths && g.paths[0]) || [];
            geom = {
              type:"LineString",
              coordinates: firstPath.map(function(pair){ return [pair[0], pair[1]]; })
            };
          }
        } else if (g.type === "polygon") {
          if (g.rings) {
            geom = {
              type:"Polygon",
              coordinates: g.rings.map(function(r){ return r.map(function(pair){ return [pair[0], pair[1]]; }); })
            };
          }
        }
        if (!geom) return;
        const props = { ...it.attributes, _layer: it.layerTitle };
        fc.features.push({ type:"Feature", geometry:geom, properties:props });
      });
      return fc;
    }

    btnCopySel.addEventListener("click", function() {
      if (!selectedItems.length) {
        showToast("Nessuna feature selezionata");
        return;
      }
      const fc = selectionToGeoJSON();
      copyToClipboard(JSON.stringify(fc, null, 2));
      showToast("GeoJSON copiato negli appunti");
    });

    btnDownloadSel.addEventListener("click", function() {
      if (!selectedItems.length) {
        showToast("Nessuna feature selezionata");
        return;
      }
      const fc = selectionToGeoJSON();
      const blob = new Blob([JSON.stringify(fc, null, 2)], { type:"application/geo+json" });
      const url = URL.createObjectURL(blob);
      const ts = new Date();
      const pad = function(n){ return String(n).padStart(2,"0"); };
      const fname = "selezione_" +
        ts.getFullYear() +
        pad(ts.getMonth()+1) +
        pad(ts.getDate()) + "_" +
        pad(ts.getHours()) +
        pad(ts.getMinutes()) +
        pad(ts.getSeconds()) + ".geojson";
      const a = document.createElement("a");
      a.href = url;
      a.download = fname;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(function(){ URL.revokeObjectURL(url); }, 2000);
    });

  });
  </script>
</body>
</html>
